### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\config\db.js
// src/config/db.js
import mongoose from 'mongoose';

const connectDB = async (uri) => {
  const mongoUri = uri || process.env.MONGO_URI;
  if (!mongoUri) {
    throw new Error('MONGO_URI not provided to connectDB');
  }

  try {
    // optional recommended settings for recent mongoose versions
    await mongoose.connect(mongoUri, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('MongoDB Connected');
  } catch (err) {
    console.error('MongoDB Connection Failed:', err.message || err);
    // rethrow so caller can decide (server.js currently exits)
    throw err;
  }
};

export default connectDB;
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\controllers\droneController.js
import Drone from '../models/drone.js';

// Get all drones
export const getDrones = async (req, res) => {
  try {
    const drones = await Drone.find();
    res.json(drones);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch drones' });
  }
};

// Add a new drone
export const addDrone = async (req, res) => {
  try {
    const { name, model, status, batteryLevel, location } = req.body;
    const drone = await Drone.create({ name, model, status, batteryLevel, location });
    res.status(201).json(drone);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create drone' });
  }
};

// Update drone status
export const updateDroneStatus = async (req, res) => {
    try {
      const { id } = req.params;
      const { status, batteryLevel, location } = req.body;
  
      const drone = await Drone.findByIdAndUpdate(
        id,
        { $set: { status, batteryLevel, location } }, // ensure $set
        { new: true, runValidators: true }
      );
  
      if (!drone) return res.status(404).json({ error: 'Drone not found' });
  
      res.json(drone);
    } catch (error) {
      res.status(500).json({ error: 'Failed to update drone' });
    }
  };
  

// Delete a drone
export const deleteDrone = async (req, res) => {
  try {
    await Drone.findByIdAndDelete(req.params.id);
    res.json({ message: 'Drone deleted' });
  } catch (error) {
    res.status(500).json({ error: 'Failed to delete drone' });
  }
};
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\controllers\missionController.js
// backend/src/controllers/missionController.js
import Mission from '../models/Mission.js';
import Drone from '../models/drone.js';
import { startTickerForMission, pauseTicker, resumeTicker } from '../utils/missionSimulator.js';

/**
 * Normalize incoming pattern values to canonical internal values.
 * Accepts 'lawnmower' from older frontends and maps to 'grid' internally.
 */
const normalizePattern = (p) => {
  if (!p) return 'grid';
  const s = String(p).toLowerCase().trim();
  if (s === 'lawnmower' || s === 'grid' || s === 'mower') return 'grid';
  if (s === 'crosshatch' || s === 'cross') return 'crosshatch';
  if (s === 'perimeter' || s === 'edge' || s === 'outline') return 'perimeter';
  // fallback to grid
  return 'grid';
};

// Get all missions
export const getMissions = async (req, res) => {
  try {
    const missions = await Mission.find().populate('drone');
    res.json(missions);
  } catch (error) {
    console.error('getMissions error:', error);
    res.status(500).json({ error: 'Failed to fetch missions' });
  }
};

// Create a mission â€” tolerant mapper for waypoint field names + clearer validation
export const createMission = async (req, res) => {
  try {
    const {
      name,
      drone,
      areaCoordinates,
      flightPath,
      altitude,
      overlap,
      pattern,
      sensors,
      swathWidth,
    } = req.body;

    // Basic validation: flightPath must be an array
    if (!Array.isArray(flightPath)) {
      return res.status(400).json({ error: 'flightPath must be an array of waypoints' });
    }
    if (flightPath.length === 0) {
      return res.status(400).json({ error: 'flightPath contains no waypoints' });
    }

    // Normalize areaCoordinates into objects with numbers (defensive)
    const normalizedArea = (areaCoordinates || []).map((pt) => {
      if (Array.isArray(pt) && pt.length >= 2) {
        const lat = Number(pt[0]), lng = Number(pt[1]);
        return { lat: Number.isFinite(lat) ? lat : null, lng: Number.isFinite(lng) ? lng : null };
      }
      if (pt && typeof pt === 'object') {
        const lat = Number(pt.lat ?? pt.latitude ?? pt[0]);
        const lng = Number(pt.lng ?? pt.longitude ?? pt[1]);
        return { lat: Number.isFinite(lat) ? lat : null, lng: Number.isFinite(lng) ? lng : null };
      }
      return { lat: null, lng: null };
    }).filter(p => p.lat !== null && p.lng !== null);

    // Validate and map waypoints
    const mappedFlightPath = [];
    for (let i = 0; i < flightPath.length; i++) {
      const wp = flightPath[i] || {};
      let lat = wp.lat ?? wp.latitude ?? (Array.isArray(wp) ? wp[0] : undefined);
      let lng = wp.lng ?? wp.longitude ?? (Array.isArray(wp) ? wp[1] : undefined);
      let alt = wp.alt ?? wp.altitude ?? (Array.isArray(wp) ? wp[2] : undefined) ?? altitude ?? 50;

      lat = Number(lat);
      lng = Number(lng);
      alt = Number(alt);

      if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
        return res.status(422).json({
          error: `Invalid waypoint at index ${i}: expected finite lat/lng.`,
          waypoint: wp,
          index: i,
        });
      }

      mappedFlightPath.push({
        lat,
        lng,
        altitude: alt,
        alt,
        order: i,
      });
    }

    // Normalize pattern and set both top-level and parameters.pattern
    const canonicalPattern = normalizePattern(pattern);

    // Build mission document
    const missionDoc = {
      name,
      drone,
      areaCoordinates: normalizedArea,
      flightPath: mappedFlightPath,
      pattern: canonicalPattern, // top-level convenience
      parameters: {
        altitude: altitude ?? 50,
        overlap: overlap ?? 20,
        pattern: canonicalPattern,
        sensors: sensors ?? ['camera'],
        frequency: 1,
        swathWidth: swathWidth ?? undefined,
      },
      status: 'planned',
      progress: 0,
      simIndex: 0,
      simProgress: 0,
    };

    // Create mission and handle mongoose validation errors explicitly
    try {
      const mission = await Mission.create(missionDoc);

      if (drone) {
        try {
          await Drone.findByIdAndUpdate(drone, { status: 'in-mission' });
        } catch (err) {
          console.warn('Failed to set drone status after mission create:', err);
        }
      }

      return res.status(201).json(mission);
    } catch (createErr) {
      console.error('Mission.create failed:', createErr && createErr.stack ? createErr.stack : createErr);
      if (createErr.name === 'ValidationError') {
        return res.status(422).json({ error: 'ValidationError', details: createErr.errors });
      }
      return res.status(500).json({ error: 'Mission creation failed', detail: createErr.message });
    }
  } catch (error) {
    console.error('createMission top-level error:', error && error.stack ? error.stack : error);
    return res.status(500).json({ error: error.message || 'Failed to create mission' });
  }
};

// Update mission
export const updateMission = async (req, res) => {
  try {
    const { id } = req.params;
    // allow runValidators
    const mission = await Mission.findByIdAndUpdate(id, req.body, { new: true, runValidators: true });
    if (!mission) return res.status(404).json({ error: 'Mission not found' });

    if (req.body.status === 'completed' || req.body.status === 'aborted') {
      try {
        await Drone.findByIdAndUpdate(mission.drone, { status: 'available' });
      } catch (err) {
        console.warn('Failed to set drone available on mission update:', err);
      }
    }
    res.json(mission);
  } catch (error) {
    console.error('updateMission error:', error);
    res.status(500).json({ error: 'Failed to update mission' });
  }
};

// Delete mission
export const deleteMission = async (req, res) => {
  try {
    await Mission.findByIdAndDelete(req.params.id);
    res.json({ message: 'Mission deleted' });
  } catch (error) {
    console.error('deleteMission error:', error);
    res.status(500).json({ error: 'Failed to delete mission' });
  }
};

// Pause mission
export const pauseMission = async (req, res) => {
  try {
    const mission = await Mission.findById(req.params.id);
    if (!mission) return res.status(404).json({ error: 'Mission not found' });
    if (mission.status !== 'in-progress') return res.status(400).json({ error: 'Mission not in progress' });

    mission.status = 'paused';
    await mission.save();
    pauseTicker(mission._id.toString());
    res.json(mission);
  } catch (error) {
    console.error('pauseMission error:', error);
    res.status(500).json({ error: 'Failed to pause mission' });
  }
};

// Resume mission
export const resumeMission = async (req, res) => {
  try {
    const mission = await Mission.findById(req.params.id).populate('drone');
    if (!mission) return res.status(404).json({ error: 'Mission not found' });
    if (mission.status !== 'paused') return res.status(400).json({ error: 'Mission not paused' });

    mission.status = 'in-progress';
    await mission.save();

    const droneId = mission.drone && mission.drone._id ? mission.drone._id : mission.drone;
    if (droneId) {
      try {
        await Drone.findByIdAndUpdate(droneId, { status: 'in-mission' });
      } catch (err) {
        console.warn('Failed to set drone in-mission on resume:', err);
      }
    }

    resumeTicker(mission._id.toString());
    res.json(mission);
  } catch (error) {
    console.error('resumeMission error:', error);
    res.status(500).json({ error: 'Failed to resume mission' });
  }
};

// Abort mission
export const abortMission = async (req, res) => {
  try {
    const mission = await Mission.findById(req.params.id);
    if (!mission) return res.status(404).json({ error: 'Mission not found' });

    mission.status = 'aborted';
    mission.progress = 0;
    mission.simIndex = 0;
    mission.simProgress = 0;
    await mission.save();
    await Drone.findByIdAndUpdate(mission.drone, { status: 'available' });
    pauseTicker(mission._id.toString());
    res.json(mission);
  } catch (error) {
    console.error('abortMission error:', error);
    res.status(500).json({ error: 'Failed to abort mission' });
  }
};

// Start mission
export const startMission = async (req, res) => {
  try {
    const mission = await Mission.findById(req.params.id).populate('drone');
    if (!mission) return res.status(404).json({ error: 'Mission not found' });
    if (mission.status !== 'planned') {
      return res.status(400).json({ error: `Mission already ${mission.status}` });
    }

    mission.status = 'in-progress';
    mission.progress = 0;
    mission.simIndex = 0;
    mission.simProgress = 0;
    await mission.save();

    const droneId = mission.drone && mission.drone._id ? mission.drone._id : mission.drone;
    if (droneId) {
      await Drone.findByIdAndUpdate(droneId, { status: 'in-mission' });
    }

    await startTickerForMission(mission._id.toString());

    res.json({ message: 'Mission started', mission });
  } catch (error) {
    console.error('Failed to start mission', error);
    res.status(500).json({ error: 'Failed to start mission' });
  }
};
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\controllers\reportController.js
import Report from '../models/Report.js';
import Mission from '../models/Mission.js';

// Get all reports
export const getReports = async (req, res) => {
  try {
    const reports = await Report.find().populate('mission').populate('drone');
    res.json(reports);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch reports' });
  }
};

// Create a report
export const createReport = async (req, res) => {
  try {
    const report = await Report.create(req.body);

    // Update mission status to completed when report is created
    await Mission.findByIdAndUpdate(req.body.mission, { status: 'completed', progress: 100 });

    res.status(201).json(report);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create report' });
  }
};

// Get analytics summary
export const getAnalytics = async (req, res) => {
  try {
    const totalReports = await Report.countDocuments();
    const totalDistance = await Report.aggregate([{ $group: { _id: null, total: { $sum: "$distance" } } }]);
    const totalCoverage = await Report.aggregate([{ $group: { _id: null, total: { $sum: "$coverage" } } }]);

    res.json({
      totalReports,
      totalDistance: totalDistance[0]?.total || 0,
      totalCoverage: totalCoverage[0]?.total || 0
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch analytics' });
  }
};
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\models\drone.js
import mongoose from 'mongoose';

const droneSchema = new mongoose.Schema({
  name: { type: String, required: true },
  model: { type: String, required: true },
  status: { type: String, enum: ['available', 'in-mission', 'charging', 'maintenance'], default: 'available' },
  batteryLevel: { type: Number, min: 0, max: 100, default: 100 },
  lastMaintenance: { type: Date, default: Date.now },
  location: {
    lat: { type: Number, default: 0 },
    lng: { type: Number, default: 0 }
  }
}, { timestamps: true });

export default mongoose.model('Drone', droneSchema);
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\models\Mission.js
// backend/src/models/Mission.js
import mongoose from 'mongoose';

const flightPointSchema = new mongoose.Schema(
  {
    lat: { type: Number, required: true },
    lng: { type: Number, required: true },
    altitude: { type: Number }, // canonical altitude
    alt: { type: Number }, // some code uses `alt`
    order: { type: Number, default: 0 },
  },
  { _id: false }
);

const missionSchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    // mission may require an assigned drone
    drone: { type: mongoose.Schema.Types.ObjectId, ref: 'Drone', required: true },

    // Survey polygon
    areaCoordinates: [{ lat: Number, lng: Number }],

    // ordered waypoints
    flightPath: [flightPointSchema],

    // top-level pattern (convenience for older frontend code)
    pattern: { type: String, enum: ['grid', 'lawnmower', 'crosshatch', 'perimeter'], default: 'grid' },

    status: {
      type: String,
      enum: ['planned', 'in-progress', 'paused', 'completed', 'aborted'],
      default: 'planned',
    },

    parameters: {
      altitude: { type: Number, default: 50 },
      overlap: { type: Number, default: 20 },
      // Accept both canonical and common alias to avoid create-time validation issues.
      pattern: { type: String, enum: ['grid', 'lawnmower', 'crosshatch', 'perimeter'], default: 'grid' },
      sensors: { type: [String], default: ['camera'] },
      frequency: { type: Number, default: 1 },
      swathWidth: { type: Number },
    },

    progress: { type: Number, default: 0 },
    estimatedTime: { type: Number, default: 0 },

    // Persist simulation state for workers / simulator to resume reliably
    simIndex: { type: Number, default: 0 },
    simProgress: { type: Number, default: 0 },
  },
  { timestamps: true }
);

export default mongoose.model('Mission', missionSchema);
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\models\Report.js
import mongoose from 'mongoose';

const reportSchema = new mongoose.Schema({
  mission: { type: mongoose.Schema.Types.ObjectId, ref: 'Mission', required: true },
  drone: { type: mongoose.Schema.Types.ObjectId, ref: 'Drone', required: true },
  duration: { type: Number, required: true }, // Minutes
  distance: { type: Number, required: true }, // Meters
  coverage: { type: Number, required: true }, // Square meters
  notes: { type: String, default: '' }
}, { timestamps: true });

export default mongoose.model('Report', reportSchema);
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\routes\droneRoutes.js
import express from 'express';
import { getDrones, addDrone, updateDroneStatus, deleteDrone } from '../controllers/droneController.js';

const router = express.Router();

router.get('/', getDrones);
router.post('/', addDrone);
router.put('/:id', updateDroneStatus);
router.delete('/:id', deleteDrone);

export default router;
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\routes\missionRoutes.js
import express from 'express';
import {
  getMissions,
  createMission,
  updateMission,
  deleteMission,
  pauseMission,
  resumeMission,
  abortMission,
  startMission
} from '../controllers/missionController.js';

const router = express.Router();

router.get('/', getMissions);
router.post('/', createMission);
router.put('/:id', updateMission);
router.delete('/:id', deleteMission);

router.post('/:id/start', startMission);
router.patch('/:id/pause', pauseMission);
router.patch('/:id/resume', resumeMission);
router.patch('/:id/abort', abortMission);

export default router;
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\routes\reportRoutes.js
import express from 'express';
import { getReports, createReport, getAnalytics } from '../controllers/reportController.js';

const router = express.Router();

router.get('/', getReports);
router.post('/', createReport);
router.get('/analytics', getAnalytics);

export default router;
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\scripts\resetDB.js
// src/scripts/resetDB.js
import dotenv from 'dotenv';
dotenv.config();

import mongoose from 'mongoose';
import Drone from '../models/drone.js';
import Mission from '../models/Mission.js';

async function resetDB() {
  try {
    console.log('Connecting to DB...');
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });

    console.log('Resetting drones...');
    await Drone.updateMany({}, { $set: { status: 'available', batteryLevel: 100 } });

    console.log('Resetting missions...');
    await Mission.updateMany({}, { $set: { status: 'planned', progress: 0, simIndex: 0, simProgress: 0 } });

    console.log('âœ” Database reset complete');
    process.exit(0);
  } catch (err) {
    console.error('âœ– Reset failed:', err);
    process.exit(1);
  }
}

resetDB();
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\utils\missionQueue.js
// src/utils/missionQueue.js
import { Queue, Worker } from 'bullmq';
import IORedis from 'ioredis';
import Mission from '../models/Mission.js';
import Drone from '../models/drone.js';

const connection = new IORedis(process.env.REDIS_URL || undefined);

export const missionQueue = new Queue('missionQueue', { connection });

export const startMissionWorker = (io) => {
  new Worker(
    'missionQueue',
    async (job) => {
      const { missionId } = job.data;
      const mission = await Mission.findById(missionId).populate('drone');
      if (!mission || mission.status !== 'in-progress') return;

      if (typeof mission.simIndex !== 'number') mission.simIndex = 0;
      if (typeof mission.simProgress !== 'number') mission.simProgress = 0;

      const path = mission.flightPath;
      if (!Array.isArray(path) || path.length < 2) return;

      const from = path[mission.simIndex] ?? path[0];
      const to = path[mission.simIndex + 1] ?? from;

      mission.simProgress += 0.1;
      if (mission.simProgress > 1) {
        mission.simProgress = 0;
        mission.simIndex++;
      }

      if (mission.simIndex >= path.length - 1) {
        mission.status = 'completed';
        mission.progress = 100;
        await Drone.findByIdAndUpdate(mission.drone._id ?? mission.drone, { status: 'available' });
      } else {
        mission.progress = Math.floor((mission.simIndex / (path.length - 1)) * 100);
      }

      const currentPosition = {
        lat: from.lat + ((to.lat - from.lat) * mission.simProgress),
        lng: from.lng + ((to.lng - from.lng) * mission.simProgress),
        alt: (from.alt ?? from.altitude ?? 0) + ((to.alt ?? to.altitude ?? 0) - (from.alt ?? from.altitude ?? 0)) * mission.simProgress,
      };

      await mission.save();

      io?.emit?.('missionProgress', {
        missionId: mission._id,
        droneId: mission.drone._id ?? mission.drone,
        status: mission.status,
        progress: mission.progress,
        currentWaypoint: currentPosition,
      });
    },
    { connection }
  );
};
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\utils\missionSimulator.js
// src/utils/missionSimulator.js
import dotenv from 'dotenv';
dotenv.config();

import Mission from '../models/Mission.js';
import Drone from '../models/drone.js';

const TICK_MS = Number(process.env.SIM_INTERVAL_MS || '1000');
const DRONE_SPEED_MPS = Number(process.env.SIM_SPEED_MPS || '8');
const BATTERY_DRAIN_PER_TICK = Number(process.env.SIM_DRAIN_PER_TICK || '0.15');

let ioRef = null;
const timers = new Map();

function distMeters(a, b) {
  if (!a || !b) return 0;
  const R = 6371000;
  const toRad = (d) => (d * Math.PI) / 180;
  const dLat = toRad(b.lat - a.lat);
  const dLng = toRad(b.lng - a.lng);
  const s1 = Math.sin(dLat / 2) ** 2;
  const s2 = Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.sin(dLng / 2) ** 2;
  return 2 * R * Math.asin(Math.sqrt(Math.max(0, s1 + s2)));
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function lerpPos(a, b, t, altA, altB) {
  return {
    lat: lerp(a.lat, b.lat, t),
    lng: lerp(a.lng, b.lng, t),
    alt: lerp(altA, altB, t),
  };
}

export function initSimulator(ioInstance) {
  ioRef = ioInstance;
}

/** Start or restart the ticker for a mission */
export async function startTickerForMission(missionId) {
  stopTicker(missionId); // ensure single timer

  const mission = await Mission.findById(missionId).populate('drone');
  if (!mission || !Array.isArray(mission.flightPath) || mission.flightPath.length < 2) return;

  mission.status = 'in-progress';
  mission.simIndex = mission.simIndex ?? 0;
  mission.simProgress = mission.simProgress ?? 0;
  await mission.save();

  const tick = async () => {
    try {
      const m = await Mission.findById(missionId).populate('drone');
      if (!m) return stopTicker(missionId);
      if (m.status !== 'in-progress') return; // do nothing until resumed

      const path = m.flightPath;
      if (!Array.isArray(path) || path.length < 2) return;

      const lastIdx = path.length - 1;
      m.simIndex = Math.max(0, Math.min(m.simIndex ?? 0, lastIdx - 1));
      const from = path[m.simIndex];
      const to = path[m.simIndex + 1] || path[m.simIndex];

      const altA = from.alt ?? from.altitude ?? m.parameters?.altitude ?? 50;
      const altB = to.alt ?? to.altitude ?? m.parameters?.altitude ?? 50;

      const segLen = Math.max(1, distMeters(from, to));
      const segDuration = Math.max(0.001, segLen / Math.max(0.001, DRONE_SPEED_MPS));
      const delta = TICK_MS / 1000 / segDuration;
      m.simProgress = (m.simProgress ?? 0) + delta;

      if (m.simProgress >= 1) {
        m.simProgress = 0;
        m.simIndex++;
      }

      const i = Math.min(m.simIndex, lastIdx - 1);
      const A = path[i];
      const B = path[i + 1] || A;
      const aA = A.alt ?? A.altitude ?? altA;
      const aB = B.alt ?? B.altitude ?? altB;
      const pos = lerpPos(A, B, m.simProgress, aA, aB);

      const overall = Math.min(99, Math.floor((i / lastIdx) * 100));
      m.progress = overall;

      if (m.simIndex >= lastIdx && m.simProgress >= 1) {
        m.status = 'completed';
        m.progress = 100;
        await Drone.findByIdAndUpdate(m.drone._id ?? m.drone, { status: 'available' });
        await m.save();
        if (ioRef) {
          ioRef.emit('missionProgress', {
            missionId: m._id,
            droneId: m.drone._id ?? m.drone,
            status: m.status,
            progress: m.progress,
            currentWaypoint: pos,
            battery: m.drone?.batteryLevel,
            speed: DRONE_SPEED_MPS,
          });
        }
        return stopTicker(missionId);
      }

      // update drone state
      const drone = await Drone.findById(m.drone._id ?? m.drone);
      const newBattery = Math.max(0, (drone?.batteryLevel ?? 100) - BATTERY_DRAIN_PER_TICK);
      await Drone.findByIdAndUpdate(m.drone._id ?? m.drone, {
        $set: { batteryLevel: newBattery, location: { lat: pos.lat, lng: pos.lng } },
      });

      await m.save();

      if (ioRef) {
        ioRef.emit('missionProgress', {
          missionId: m._id,
          droneId: m.drone._id ?? m.drone,
          status: m.status,
          progress: m.progress,
          currentWaypoint: pos,
          battery: newBattery,
          speed: DRONE_SPEED_MPS,
        });
      }
    } catch (err) {
      console.error('Ticker tick error:', err);
    }
  };

  const id = setInterval(tick, TICK_MS);
  timers.set(missionId, { id, paused: false });
}

export async function pauseTicker(missionId) {
  const mission = await Mission.findByIdAndUpdate(missionId, { status: 'paused' }, { new: true });
  const t = timers.get(missionId);
  if (t && !t.paused) {
    clearInterval(t.id);
    timers.set(missionId, { ...t, paused: true });
  }
  return mission;
}

export async function resumeTicker(missionId) {
  const mission = await Mission.findByIdAndUpdate(missionId, { status: 'in-progress' }, { new: true });
  const t = timers.get(missionId);
  if (t && t.paused) {
    clearInterval(t.id);
    timers.delete(missionId);
  }
  await startTickerForMission(missionId);
  return mission;
}

export async function abortTicker(missionId) {
  const mission = await Mission.findByIdAndUpdate(
    missionId,
    { status: 'aborted', progress: 0, simIndex: 0, simProgress: 0 },
    { new: true }
  );
  stopTicker(missionId);
  if (mission?.drone) {
    await Drone.findByIdAndUpdate(mission.drone._id ?? mission.drone, { status: 'available' });
  }
  return mission;
}

function stopTicker(missionId) {
  const t = timers.get(missionId);
  if (t) {
    clearInterval(t.id);
    timers.delete(missionId);
  }
}
### FILE: C:\Users\yash2\OneDrive\Desktop\Drone-App\backend\src\server.js
// backend/src/server.js
import dotenv from 'dotenv';
dotenv.config();

import express from 'express';
import cors from 'cors';
import connectDB from './config/db.js';
import droneRoutes from './routes/droneRoutes.js';
import missionRoutes from './routes/missionRoutes.js';
import { createServer } from 'http';
import { Server } from 'socket.io';
import { initSimulator } from './utils/missionSimulator.js';

const app = express();
app.use(cors());

// Increase body parser limits to allow large flightPath payloads (adjust as needed)
app.use(express.json({ limit: '20mb' }));
app.use(express.urlencoded({ extended: true, limit: '20mb' }));

// Optional: small middleware to log incoming Content-Length for debugging (remove in prod)
if (process.env.NODE_ENV !== 'production') {
  app.use((req, res, next) => {
    const cl = req.headers['content-length'];
    if (cl) console.log(`[dev] Incoming ${req.method} ${req.path} - Content-Length: ${cl} bytes`);
    next();
  });
}

// Routes
app.use('/api/drones', droneRoutes);
app.use('/api/missions', missionRoutes);

// Base Route
app.get('/', (req, res) => {
  res.json({ message: 'Drone Survey API Running' });
});

const PORT = process.env.PORT || 5000;

(async function main() {
  try {
    // 1) Connect to MongoDB
    console.log('Connecting to MongoDB...');
    await connectDB(process.env.MONGO_URI);
    console.log('MongoDB connected');

    // 2) Create HTTP + Socket.IO server
    const httpServer = createServer(app);
    const io = new Server(httpServer, { cors: { origin: '*' } });

    // 3) (Optional) If you run multiple Node instances, you can wire a Redis adapter here.
    //    For now we skip it to avoid Redis OOM/eviction issues.

    // 4) Socket.IO handlers
    io.on('connection', (socket) => {
      console.log('Client connected:', socket.id);

      socket.on('pauseMission', (missionId) => {
        io.emit('missionControl', { missionId, action: 'pause' });
      });

      socket.on('resumeMission', (missionId) => {
        io.emit('missionControl', { missionId, action: 'resume' });
      });

      socket.on('abortMission', (missionId) => {
        io.emit('missionControl', { missionId, action: 'abort' });
      });

      socket.on('disconnect', () => {
        console.log('Client disconnected:', socket.id);
      });
    });

    // 5) Init in-process simulator with IO
    initSimulator(io);

    // 6) Start HTTP server
    httpServer.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  } catch (err) {
    console.error('Server startup failed:', err);
    process.exit(1);
  }
})();
